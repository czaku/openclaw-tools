#!/bin/bash
set -euo pipefail

# =============================================================================
# openclaw-tools — Interactive TUI for managing OpenClaw on macOS and Linux
# =============================================================================
#
# A single interactive tool for everything OpenClaw on your machine:
# setup, profiles, status, backups, migrations, and clean uninstalls.
#
# Just run it — no flags, no subcommands, no docs to read.
# Requires: gum (installed automatically by install.sh)
#
# =============================================================================

# ── Check for gum ────────────────────────────────────────────────────────
if ! command -v gum &>/dev/null; then
    echo "Error: 'gum' is required but not installed."
    echo ""
    echo "  Install with: brew install gum       (macOS)"
    echo "                sudo apt install gum   (Linux)"
    echo ""
    echo "  Or run install.sh which installs gum automatically."
    exit 1
fi

# ── Colors ───────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ── Platform detection ───────────────────────────────────────────────────
PLATFORM="$(uname -s)"

case "$PLATFORM" in
    Darwin)
        PLATFORM_NAME="macOS"
        PLATFORM_SHORT="Mac"
        NODE_INSTALL_HINT="brew install node"
        SHARED_PATH="/Users/Shared"
        DAEMON_TYPE="LaunchAgent"
        ;;
    Linux)
        PLATFORM_NAME="Linux"
        PLATFORM_SHORT="machine"
        NODE_INSTALL_HINT="sudo apt install nodejs  # or: sudo dnf install nodejs"
        SHARED_PATH="/usr/local/share"
        DAEMON_TYPE="systemd service"
        ;;
    *)
        echo "Unsupported OS: $PLATFORM (only macOS and Linux are supported)" >&2
        exit 1
        ;;
esac

# ── Platform wrappers ────────────────────────────────────────────────────
# All platform-specific code is in these functions. The rest of the script
# calls only these wrappers — no raw lsof/launchctl/sed scattered around.

port_is_listening() {
    local port="$1"
    if command -v lsof &>/dev/null; then
        lsof -i :"$port" -sTCP:LISTEN &>/dev/null
    elif command -v ss &>/dev/null; then
        ss -tlnp 2>/dev/null | grep -qE ":${port}\b"
    else
        (echo > /dev/tcp/127.0.0.1/"$port") 2>/dev/null
    fi
}

port_listener_owner() {
    local port="$1"
    if command -v lsof &>/dev/null; then
        lsof -i :"$port" -sTCP:LISTEN -nP 2>/dev/null | grep -v COMMAND | head -1 | awk '{print $3}'
    elif command -v ss &>/dev/null; then
        local pid
        pid=$(ss -tlnp 2>/dev/null | grep -E ":${port}\b" | sed -n 's/.*pid=\([0-9]*\).*/\1/p' | head -1)
        [[ -n "$pid" ]] && ps -o user= -p "$pid" 2>/dev/null || true
    fi
}

port_listener_pid() {
    local port="$1"
    if command -v lsof &>/dev/null; then
        lsof -i :"$port" -sTCP:LISTEN -t 2>/dev/null | head -1
    elif command -v ss &>/dev/null; then
        ss -tlnp 2>/dev/null | grep -E ":${port}\b" | sed -n 's/.*pid=\([0-9]*\).*/\1/p' | head -1
    fi
}

port_listener_pids() {
    local port="$1"
    if command -v lsof &>/dev/null; then
        lsof -i :"$port" -sTCP:LISTEN -t 2>/dev/null
    elif command -v ss &>/dev/null; then
        ss -tlnp 2>/dev/null | grep -E ":${port}\b" | sed -n 's/.*pid=\([0-9]*\).*/\1/p'
    fi
}

port_listener_is_node() {
    local port="$1"
    if command -v lsof &>/dev/null; then
        lsof -i :"$port" -sTCP:LISTEN -nP 2>/dev/null | grep -q node
    elif command -v ss &>/dev/null; then
        local pid
        pid=$(ss -tlnp 2>/dev/null | grep -E ":${port}\b" | sed -n 's/.*pid=\([0-9]*\).*/\1/p' | head -1)
        [[ -n "$pid" ]] && ps -o comm= -p "$pid" 2>/dev/null | grep -q node
    else
        return 1
    fi
}

daemon_install() {
    local profile="$1"
    if [[ -n "$profile" ]]; then
        openclaw --profile "$profile" gateway install --force 2>&1 | tail -3
    else
        openclaw gateway install --force 2>&1 | tail -3
    fi
    info "$DAEMON_TYPE installed${profile:+ (ai.openclaw.$profile)}"
}

daemon_start() {
    local profile="$1"
    if [[ -n "$profile" ]]; then
        openclaw --profile "$profile" gateway start 2>&1 | tail -3
    else
        openclaw gateway start 2>&1 | tail -3
    fi
    info "Gateway start requested"
}

daemon_uninstall() {
    local profile="$1"

    if [[ "$PLATFORM" == "Darwin" ]]; then
        local plist_name="ai.openclaw.gateway.plist"
        [[ -n "$profile" ]] && plist_name="ai.openclaw.${profile}.plist"
        local plist="$HOME/Library/LaunchAgents/$plist_name"
        if [[ -f "$plist" ]]; then
            launchctl unload "$plist" 2>/dev/null || true
            rm -f "$plist"
            info "Removed $DAEMON_TYPE${profile:+ for '$profile'}"
        else
            info "No $DAEMON_TYPE found${profile:+ for '$profile'} (already removed)"
        fi
    elif [[ "$PLATFORM" == "Linux" ]]; then
        local service_name="openclaw-gateway"
        [[ -n "$profile" ]] && service_name="openclaw-${profile}"
        if systemctl --user cat "${service_name}.service" &>/dev/null 2>&1; then
            systemctl --user stop "${service_name}.service" 2>/dev/null || true
            systemctl --user disable "${service_name}.service" 2>/dev/null || true
            rm -f "$HOME/.config/systemd/user/${service_name}.service"
            systemctl --user daemon-reload 2>/dev/null || true
            info "Removed $DAEMON_TYPE${profile:+ for '$profile'}"
        else
            info "No $DAEMON_TYPE found${profile:+ for '$profile'} (already removed)"
        fi
    fi
}

sed_inplace() {
    local expression="$1"
    local file="$2"
    if [[ "$PLATFORM" == "Darwin" ]]; then
        sed -i '' "$expression" "$file"
    else
        sed -i "$expression" "$file"
    fi
}

stat_permissions() {
    local path="$1"
    stat -f '%Lp' "$path" 2>/dev/null || stat -c '%a' "$path" 2>/dev/null
}

get_desktop_path() {
    if command -v xdg-user-dir &>/dev/null; then
        xdg-user-dir DESKTOP 2>/dev/null || echo "$HOME"
    elif [[ -d "$HOME/Desktop" ]]; then
        echo "$HOME/Desktop"
    else
        echo "$HOME"
    fi
}

# ── Output helpers ───────────────────────────────────────────────────────
info()  { echo -e "  ${GREEN}✓${NC} $1"; }
warn()  { echo -e "  ${YELLOW}!${NC} $1"; }
fail()  { echo -e "  ${RED}✗${NC} $1"; }
step()  { echo -e "\n  ${CYAN}─── $1 ───${NC}\n"; }

wait_for_key() {
    echo ""
    read -rp "  Press any key to return to menu..." -n1 -s
}

# ── Loading indicator ───────────────────────────────────────────────────
# Shows a simple "Loading..." message, runs the function, then clears it.
with_loading() {
    local msg="${1:-Loading...}"; shift
    echo -ne "  ${DIM}${msg}${NC}"
    "$@"
    # Clear the loading line
    echo -ne "\r\033[K"
}

# ── Status detection ─────────────────────────────────────────────────────
STATUS_LINES=()
HAS_DEFAULT_CONFIG=false
DEFAULT_PORT=""
DEFAULT_RUNNING=false
CURRENT_USER=""

_detect_status_work() {
    CURRENT_USER=$(whoami)
    STATUS_LINES=()
    HAS_DEFAULT_CONFIG=false
    DEFAULT_PORT=""
    DEFAULT_RUNNING=false

    if [[ -f "$HOME/.openclaw/openclaw.json" ]]; then
        HAS_DEFAULT_CONFIG=true
        DEFAULT_PORT=$(python3 -c "
import json
try:
    c = json.load(open('$HOME/.openclaw/openclaw.json'))
    print(c.get('gateway', {}).get('port', ''))
except: pass
" 2>/dev/null || true)

        if [[ -n "$DEFAULT_PORT" ]] && port_is_listening "$DEFAULT_PORT"; then
            DEFAULT_RUNNING=true
            STATUS_LINES+=("  ● $CURRENT_USER — port $DEFAULT_PORT (running)")
        else
            STATUS_LINES+=("  ✗ $CURRENT_USER — port ${DEFAULT_PORT:-?} (stopped)")
        fi
    fi

    for d in "$HOME"/.openclaw-*/; do
        [[ -d "$d" ]] || continue
        local pname
        pname=$(basename "$d" | sed 's/^\.openclaw-//')
        local pport
        pport=$(python3 -c "
import json
try:
    c = json.load(open('$d/openclaw.json'))
    print(c.get('gateway', {}).get('port', ''))
except: pass
" 2>/dev/null || true)

        if [[ -n "$pport" ]] && port_is_listening "$pport"; then
            STATUS_LINES+=("  ● $pname — port $pport (running)")
        else
            STATUS_LINES+=("  ○ $pname — port ${pport:-?} (stopped)")
        fi
    done

    for port in 18728 18789 18828 18900 18928 19001; do
        port_listener_is_node "$port" 2>/dev/null || continue
        local owner
        owner=$(port_listener_owner "$port")
        [[ -n "$owner" ]] || continue
        [[ "$owner" != "$CURRENT_USER" ]] || continue
        local already=false
        for sl in "${STATUS_LINES[@]}"; do
            [[ "$sl" == *"port $port"* ]] && already=true
        done
        [[ "$already" == false ]] && STATUS_LINES+=("  ● $owner — port $port (running)")
    done

    if [[ ${#STATUS_LINES[@]} -eq 0 ]]; then
        STATUS_LINES+=("  No OpenClaw instances found on this $PLATFORM_SHORT")
    fi
}

detect_status() {
    with_loading "Loading..." _detect_status_work
}

# Build a status header string for gum style
status_header() {
    local lines="This $PLATFORM_SHORT:"
    for sl in "${STATUS_LINES[@]}"; do
        lines="$lines
$sl"
    done
    echo "$lines"
}

# ═══════════════════════════════════════════════════════════════════════════
# SETUP WIZARD
# ═══════════════════════════════════════════════════════════════════════════

run_setup() {
    clear
    step "Pre-flight"

    if ! command -v node &>/dev/null; then
        fail "node not found. Install with: $NODE_INSTALL_HINT"
        wait_for_key
        return
    fi
    info "node $(node --version)"

    if ! command -v openclaw &>/dev/null; then
        fail "openclaw not found. Install with: npm install -g openclaw"
        wait_for_key
        return
    fi
    info "openclaw found"

    if [[ "$(whoami)" == "root" ]]; then
        fail "Don't run as root. Run as the user who will use OpenClaw."
        wait_for_key
        return
    fi
    info "User: $CURRENT_USER"
    echo ""

    if [[ "$HAS_DEFAULT_CONFIG" == false ]]; then
        echo -e "  You ${BOLD}($CURRENT_USER)${NC} don't have OpenClaw configured yet."
        echo "  Let's set it up!"
        echo ""
        setup_fresh_default
    else
        local choice
        choice=$(gum choose --header "Set up OpenClaw" \
            "Add another bot on this account" \
            "Reconfigure your current setup" \
            "Set up a different $PLATFORM_NAME user account" \
            "← Back") || return

        case "$choice" in
            "Add another"*) setup_new_profile ;;
            "Reconfigure"*) setup_reconfigure ;;
            "Set up a different"*) setup_different_user ;;
            *) return ;;
        esac
    fi
}

setup_fresh_default() {
    local port
    port=$(pick_port "")

    step "Creating directories"
    mkdir -p "$HOME/.openclaw"/{workspace,logs,agents/main/sessions,credentials}
    info "Created ~/.openclaw/"

    step "Writing config"
    python3 -c "
import json, secrets
cfg = {
    'gateway': {
        'port': $port,
        'mode': 'local',
        'auth': {
            'mode': 'token',
            'token': secrets.token_hex(24)
        }
    }
}
with open('$HOME/.openclaw/openclaw.json', 'w') as f:
    json.dump(cfg, f, indent=2)
    f.write('\n')
"
    info "Config written (port=$port, mode=local)"

    step "Auth token"
    info "Gateway auth token generated"

    check_tmp_permissions

    step "Starting daemon"
    daemon_install ""
    daemon_start ""

    verify_gateway "$port" ""
}

setup_new_profile() {
    clear
    step "New bot profile"

    echo "  This creates a separate OpenClaw instance with its own"
    echo "  port, API keys, Slack bot, dashboard, and daemon."
    echo ""

    echo "  Existing profiles:"
    local found=false
    for d in "$HOME"/.openclaw-*/; do
        [[ -d "$d" ]] || continue
        found=true
        local pn
        pn=$(basename "$d" | sed 's/^\.openclaw-//')
        echo "    - $pn"
    done
    [[ "$found" == true ]] || echo "    (none)"
    echo ""

    local name
    name=$(gum input --header "Name for this bot" --placeholder "letters, numbers, hyphens") || return
    [[ -n "$name" ]] || { fail "Name cannot be empty"; wait_for_key; return; }

    if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        fail "Invalid name: use letters, numbers, hyphens, underscores"
        wait_for_key
        return
    fi

    if [[ "$name" == "default" || "$name" == "main" ]]; then
        fail "'$name' is reserved"
        wait_for_key
        return
    fi

    local profile_dir="$HOME/.openclaw-$name"
    if [[ -d "$profile_dir" ]]; then
        echo ""
        if ! gum confirm "Profile '$name' already exists. Overwrite?"; then
            return
        fi
    fi

    echo ""
    local port
    port=$(pick_port "$name")

    step "Creating profile directory"
    mkdir -p "$profile_dir"/{logs,credentials,agents/main/sessions}
    mkdir -p "$profile_dir/workspace-$name"
    info "Created $profile_dir/"

    step "Config — copy from your main OpenClaw?"
    local selected_providers=""
    local selected_channels=""
    local copy_models=false

    if [[ -f "$HOME/.openclaw/openclaw.json" ]]; then
        interactive_copy_menu
    fi

    python3 -c "
import json, secrets

default_config_path = '$HOME/.openclaw/openclaw.json'
profile_dir = '$profile_dir'
selected_providers = '$selected_providers'
selected_channels = '$selected_channels'
copy_models = '$copy_models' == 'true'
port = $port

cfg = {
    'gateway': {
        'port': port,
        'mode': 'local',
        'auth': {
            'mode': 'token',
            'token': secrets.token_hex(24)
        }
    }
}

if selected_providers or selected_channels or copy_models:
    try:
        with open(default_config_path, 'r') as f:
            default_cfg = json.load(f)
    except:
        default_cfg = {}

    if selected_providers:
        provider_list = [p.strip() for p in selected_providers.split(',') if p.strip()]
        src_profiles = default_cfg.get('auth', {}).get('profiles', {})
        selected = {k: v for k, v in src_profiles.items()
                    if v.get('provider') in provider_list}
        if selected:
            cfg['auth'] = {'profiles': selected}

    if selected_channels:
        channel_list = [c.strip() for c in selected_channels.split(',') if c.strip()]
        src_channels = default_cfg.get('channels', {})
        src_plugins = default_cfg.get('plugins', {}).get('entries', {})
        for ch in channel_list:
            if ch in src_channels:
                cfg.setdefault('channels', {})[ch] = src_channels[ch]
            if ch in src_plugins:
                cfg.setdefault('plugins', {}).setdefault('entries', {})[ch] = src_plugins[ch]

    if copy_models and 'models' in default_cfg:
        cfg['models'] = default_cfg['models']

with open(f'{profile_dir}/openclaw.json', 'w') as f:
    json.dump(cfg, f, indent=2)
    f.write('\n')
"
    info "Config written"

    if [[ -n "$selected_providers" ]] && [[ -d "$HOME/.openclaw/credentials" ]]; then
        cp -r "$HOME/.openclaw/credentials/"* "$profile_dir/credentials/" 2>/dev/null || true
        info "Copied OAuth credentials"
    fi

    step "Auth token"
    info "Gateway auth token generated"

    check_tmp_permissions

    step "Starting '$name' daemon"
    daemon_install "$name"
    daemon_start "$name"

    verify_gateway "$port" "$name"
}

# ── Interactive copy menu (gum choose --no-limit) ────────────────────────
interactive_copy_menu() {
    local avail_info
    avail_info=$(python3 -c "
import json
with open('$HOME/.openclaw/openclaw.json', 'r') as f:
    cfg = json.load(f)

providers = {}
for key, val in cfg.get('auth', {}).get('profiles', {}).items():
    prov = val.get('provider', 'unknown')
    providers.setdefault(prov, []).append(key)

channels = {}
for ch_name, ch_cfg in cfg.get('channels', {}).items():
    if isinstance(ch_cfg, dict):
        detail = ''
        allow = ch_cfg.get('allowFrom', [])
        if ch_name == 'whatsapp' and allow:
            detail = ', '.join(str(n) for n in allow[:3])
        elif ch_name == 'slack':
            detail = ch_cfg.get('name', '') or 'connected'
        elif ch_name == 'telegram':
            detail = 'bot'
        channels[ch_name] = detail
for pl_name, pl_cfg in cfg.get('plugins', {}).get('entries', {}).items():
    if isinstance(pl_cfg, dict) and pl_cfg.get('enabled', False):
        if pl_name not in channels:
            channels[pl_name] = ''

has_models = bool(cfg.get('models', {}).get('providers', {}))

prov_list = ';'.join(f'{p}:{\",\".join(keys)}' for p, keys in providers.items())
ch_list = ';'.join(f'{n}:{d}' for n, d in channels.items()) if channels else 'none'
print(f'{prov_list}|{ch_list}|{has_models}')
" 2>/dev/null || echo "||False")

    local avail_providers avail_channels avail_models
    avail_providers=$(echo "$avail_info" | cut -d'|' -f1)
    avail_channels=$(echo "$avail_info" | cut -d'|' -f2)
    avail_models=$(echo "$avail_info" | cut -d'|' -f3)

    # ── API keys ──────────────────────────────────────────────────────
    if [[ -n "$avail_providers" ]]; then
        local prov_names=()
        local prov_labels=()
        IFS=';' read -ra prov_entries <<< "$avail_providers"
        for entry in "${prov_entries[@]}"; do
            local prov_name prov_keys
            prov_name=$(echo "$entry" | cut -d':' -f1)
            prov_keys=$(echo "$entry" | cut -d':' -f2-)
            prov_names+=("$prov_name")
            prov_labels+=("$prov_name ($prov_keys)")
        done

        echo ""
        local selected_keys=""
        selected_keys=$(printf '%s\n' "${prov_labels[@]}" | \
            gum choose --no-limit \
                --header "Copy API keys from your main OpenClaw:" \
                --header.foreground 212) || true

        if [[ -n "$selected_keys" ]]; then
            local sel=()
            while IFS= read -r label; do
                for i in "${!prov_labels[@]}"; do
                    if [[ "$label" == "${prov_labels[$i]}" ]]; then
                        sel+=("${prov_names[$i]}")
                    fi
                done
            done <<< "$selected_keys"
            selected_providers=$(IFS=,; echo "${sel[*]}")
            info "Will copy: $selected_providers"
        else
            info "No API keys will be copied"
        fi
    fi

    # ── Channels ──────────────────────────────────────────────────────
    if [[ "$avail_channels" != "none" ]] && [[ -n "$avail_channels" ]]; then
        local ch_names=()
        local ch_labels=()
        IFS=';' read -ra ch_entries <<< "$avail_channels"
        for entry in "${ch_entries[@]}"; do
            local ch_name ch_detail
            ch_name=$(echo "$entry" | cut -d':' -f1)
            ch_detail=$(echo "$entry" | cut -d':' -f2-)
            ch_names+=("$ch_name")
            if [[ -n "$ch_detail" ]]; then
                ch_labels+=("$ch_name ($ch_detail)")
            else
                ch_labels+=("$ch_name")
            fi
        done

        echo ""
        echo -e "  ${DIM}Profiles are usually separate instances with their own channels."
        echo -e "  Only copy channels if you want this bot to reuse existing ones.${NC}"
        echo ""

        local selected_chs=""
        selected_chs=$(printf '%s\n' "${ch_labels[@]}" | \
            gum choose --no-limit \
                --header "Copy channels? (enter to skip)" \
                --header.foreground 212) || true

        if [[ -n "$selected_chs" ]]; then
            local sel=()
            while IFS= read -r label; do
                for i in "${!ch_labels[@]}"; do
                    if [[ "$label" == "${ch_labels[$i]}" ]]; then
                        sel+=("${ch_names[$i]}")
                    fi
                done
            done <<< "$selected_chs"
            selected_channels=$(IFS=,; echo "${sel[*]}")
            info "Will copy channels: $selected_channels"
        else
            info "No channels will be copied — you'll set up fresh ones"
        fi
    fi

    # ── Models ────────────────────────────────────────────────────────
    if [[ "$avail_models" == "True" ]] && [[ -n "$selected_providers" ]]; then
        echo ""
        if gum confirm "Also copy custom model definitions?"; then
            copy_models=true
        fi
    fi
}

# ── Reconfigure existing ─────────────────────────────────────────────────
setup_reconfigure() {
    clear
    step "Reconfigure your OpenClaw"

    local port mode status_text
    port=$(python3 -c "
import json
try:
    c = json.load(open('$HOME/.openclaw/openclaw.json'))
    print(c.get('gateway', {}).get('port', 'unset'))
except: print('unset')
" 2>/dev/null || echo "unset")

    mode=$(python3 -c "
import json
try:
    c = json.load(open('$HOME/.openclaw/openclaw.json'))
    print(c.get('gateway', {}).get('mode', 'unset'))
except: print('unset')
" 2>/dev/null || echo "unset")

    if [[ "$DEFAULT_RUNNING" == true ]]; then
        status_text="running"
    else
        status_text="stopped"
    fi

    echo "  Current config:"
    echo "    Port:   $port"
    echo "    Mode:   $mode"
    echo "    Status: $status_text"
    echo ""

    local choice
    choice=$(gum choose --header "What would you like to change?" \
        "Change port" \
        "Reset config to fresh (backs up current)" \
        "Reinstall and restart the daemon" \
        "Regenerate auth token" \
        "← Back") || return

    case "$choice" in
        "Change port")
            clear
            local new_port
            new_port=$(pick_port "")
            python3 -c "
import json
with open('$HOME/.openclaw/openclaw.json', 'r') as f:
    cfg = json.load(f)
cfg.setdefault('gateway', {})['port'] = $new_port
with open('$HOME/.openclaw/openclaw.json', 'w') as f:
    json.dump(cfg, f, indent=2)
    f.write('\n')
"
            info "Port updated to $new_port"
            daemon_install ""
            daemon_start ""
            ;;
        "Reset config"*)
            clear
            local backup="$HOME/.openclaw/openclaw.json.bak.$(date +%s)"
            cp "$HOME/.openclaw/openclaw.json" "$backup"
            info "Backed up to: $backup"
            local new_port
            new_port=$(pick_port "")
            python3 -c "
import json, secrets
cfg = {
    'gateway': {
        'port': $new_port,
        'mode': 'local',
        'auth': {
            'mode': 'token',
            'token': secrets.token_hex(24)
        }
    }
}
with open('$HOME/.openclaw/openclaw.json', 'w') as f:
    json.dump(cfg, f, indent=2)
    f.write('\n')
"
            info "Fresh config written (port=$new_port)"
            daemon_install ""
            daemon_start ""
            ;;
        "Reinstall"*)
            clear
            daemon_install ""
            daemon_start ""
            ;;
        "Regenerate auth"*)
            clear
            python3 -c "
import json, secrets
with open('$HOME/.openclaw/openclaw.json', 'r') as f:
    cfg = json.load(f)
cfg.setdefault('gateway', {}).setdefault('auth', {})['mode'] = 'token'
cfg['gateway']['auth']['token'] = secrets.token_hex(24)
with open('$HOME/.openclaw/openclaw.json', 'w') as f:
    json.dump(cfg, f, indent=2)
    f.write('\n')
"
            info "New auth token generated"
            echo "  Run 'openclaw dashboard' to get the new token URL"
            ;;
        *) return ;;
    esac
}

# ── Different user guidance ──────────────────────────────────────────────
setup_different_user() {
    clear
    step "Set up a different $PLATFORM_NAME user account"
    echo ""
    echo "  To set up OpenClaw for a different user:"
    echo ""
    if [[ "$PLATFORM" == "Darwin" ]]; then
        echo "    1. Log into their macOS account"
        echo "       (Fast User Switching, or log out and log back in)"
    else
        echo "    1. Switch to their user session"
        echo "       (su - username, or log in as that user)"
    fi
    echo ""
    echo "    2. Open Terminal"
    echo ""
    echo "    3. Run this tool:"
    echo -e "       ${BOLD}$(cd "$(dirname "$0")" && pwd)/$(basename "$0")${NC}"
    echo ""
    echo "    Or copy it to a shared location first:"
    echo "       sudo cp $(cd "$(dirname "$0")" && pwd)/$(basename "$0") $SHARED_PATH/"
    echo "       Then from the other account: $SHARED_PATH/openclaw-tools"
    echo ""
    echo "  Each $PLATFORM_NAME account gets its own isolated OpenClaw."
    echo "  They'll pick their own port and API keys."
}

# ── Port picker ──────────────────────────────────────────────────────────
pick_port() {
    local profile_name="$1"

    step "Port selection"

    echo "  Ports on this $PLATFORM_SHORT:"
    for p in 18728 18789 18828 18900 18928 19001; do
        if port_is_listening "$p"; then
            local owner
            owner=$(port_listener_owner "$p")
            echo -e "    $p — ${RED}in use by ${owner:-unknown}${NC}"
        else
            echo -e "    $p — ${GREEN}available${NC}"
        fi
    done
    echo ""

    local port_label="your OpenClaw"
    [[ -n "$profile_name" ]] && port_label="\"$profile_name\""

    while true; do
        local port
        port=$(gum input --header "Pick a port for $port_label" --placeholder "e.g. 18828") || return 1

        if [[ ! "$port" =~ ^[0-9]+$ ]]; then
            fail "Invalid port: $port"
            continue
        fi
        if [[ "$port" -lt 1024 || "$port" -gt 65535 ]]; then
            fail "Port must be 1024–65535"
            continue
        fi
        if port_is_listening "$port"; then
            local owner
            owner=$(port_listener_owner "$port")
            fail "Port $port is in use by ${owner:-unknown}"
            continue
        fi

        info "Will use port $port"
        echo "$port"
        return
    done
}

# ── Check /tmp/openclaw permissions ──────────────────────────────────────
check_tmp_permissions() {
    step "Permissions"
    if [[ -d /tmp/openclaw ]]; then
        local perms
        perms=$(stat_permissions /tmp/openclaw)
        if [[ "$perms" != "1777" ]]; then
            warn "/tmp/openclaw has permissions $perms (should be 1777)"
            echo "  Fix with: sudo chmod 1777 /tmp/openclaw"
        else
            info "/tmp/openclaw OK (1777)"
        fi
    else
        mkdir -p /tmp/openclaw
        chmod 1777 /tmp/openclaw 2>/dev/null || warn "Could not set 1777 — may need sudo"
        info "/tmp/openclaw created"
    fi
}

# ── Verify gateway ───────────────────────────────────────────────────────
verify_gateway() {
    local port="$1"
    local profile="$2"

    step "Verifying (waiting 5s)..."
    sleep 5

    if port_is_listening "$port"; then
        info "Gateway listening on port $port"
        echo ""
        echo -e "  ${GREEN}All done!${NC}"
        echo ""
        if [[ -n "$profile" ]]; then
            echo "  \"$profile\" is running as a separate OpenClaw instance."
            echo ""
            echo "  Dashboard:  openclaw --profile $profile dashboard"
            echo "  Add keys:   openclaw --profile $profile auth add anthropic my-key"
            echo "  Status:     openclaw --profile $profile doctor"
            echo "  Restart:    openclaw --profile $profile gateway restart"
            echo ""
            echo "  Tip — add to ~/.zshrc or ~/.bashrc:"
            echo "    alias oc-$profile='OPENCLAW_PROFILE=$profile openclaw'"
        else
            echo "  Dashboard:  openclaw dashboard"
            echo "  Add keys:   openclaw auth add anthropic my-key"
            echo "  Status:     openclaw doctor"
            echo "  Restart:    openclaw gateway restart"
        fi
    else
        fail "Gateway NOT detected on port $port"
        echo ""
        if [[ -n "$profile" ]]; then
            echo "  Debug:"
            echo "    tail -20 ~/.openclaw-$profile/logs/gateway.err.log"
            echo "    OPENCLAW_PROFILE=$profile openclaw gateway --port $port"
        else
            echo "  Debug:"
            echo "    tail -20 ~/.openclaw/logs/gateway.err.log"
            echo "    openclaw gateway --port $port"
        fi
    fi
}

# ═══════════════════════════════════════════════════════════════════════════
# STATUS & PROFILES
# ═══════════════════════════════════════════════════════════════════════════

_STATUS_OUTPUT=""

_collect_status_details() {
    local out=""
    local profiles=()

    if [[ -d "$HOME/.openclaw" ]]; then
        profiles+=("default|$HOME/.openclaw")
    fi

    for d in "$HOME"/.openclaw-*/; do
        [[ -d "$d" ]] || continue
        local pname
        pname=$(basename "$d" | sed 's/^\.openclaw-//')
        profiles+=("$pname|${d%/}")
    done

    if [[ ${#profiles[@]} -eq 0 ]]; then
        _STATUS_OUTPUT="__empty__"
        return
    fi

    for entry in "${profiles[@]}"; do
        local pname pdir
        pname=$(echo "$entry" | cut -d'|' -f1)
        pdir=$(echo "$entry" | cut -d'|' -f2)
        local config="$pdir/openclaw.json"

        local port="?" mode="?" auth_count="0" channels="none" has_token="false"

        if [[ -f "$config" ]]; then
            local pinfo
            pinfo=$(python3 -c "
import json
try:
    c = json.load(open('$config'))
    port = c.get('gateway', {}).get('port', '?')
    mode = c.get('gateway', {}).get('mode', '?')
    has_token = bool(c.get('gateway', {}).get('auth', {}).get('token'))
    auth_count = len(c.get('auth', {}).get('profiles', {}))
    channels = []
    for ch in c.get('channels', {}):
        channels.append(ch)
    for pl, pc in c.get('plugins', {}).get('entries', {}).items():
        if isinstance(pc, dict) and pc.get('enabled', False) and pl not in channels:
            channels.append(pl)
    ch_str = ', '.join(channels) if channels else 'none'
    print(f'{port}|{mode}|{has_token}|{auth_count}|{ch_str}')
except Exception as e:
    print(f'?|?|False|0|error: {e}')
" 2>/dev/null || echo "?|?|False|0|error")
            port=$(echo "$pinfo" | cut -d'|' -f1)
            mode=$(echo "$pinfo" | cut -d'|' -f2)
            has_token=$(echo "$pinfo" | cut -d'|' -f3)
            auth_count=$(echo "$pinfo" | cut -d'|' -f4)
            channels=$(echo "$pinfo" | cut -d'|' -f5)
        fi

        local running=false pid=""
        if [[ "$port" =~ ^[0-9]+$ ]] && port_is_listening "$port"; then
            running=true
            pid=$(port_listener_pid "$port")
        fi

        local dir_size
        dir_size=$(du -sh "$pdir" 2>/dev/null | cut -f1 || echo "?")

        if [[ "$running" == true ]]; then
            out+="  ${GREEN}●${NC} ${BOLD}$pname${NC} — port $port (running, PID ${pid:-?})"$'\n'
        else
            out+="  ${RED}○${NC} $pname — port $port (stopped)"$'\n'
        fi
        out+="    API keys: $auth_count  Channels: $channels"$'\n'
        out+="    Dir: $pdir/ ($dir_size)"$'\n'
        if [[ "$running" == true ]]; then
            out+="    Dashboard: http://localhost:$port/"$'\n'
        fi
        out+=""$'\n'
    done

    local other_found=false
    for p in 18728 18789 18828 18900 18928 19001; do
        port_listener_is_node "$p" 2>/dev/null || continue
        local owner
        owner=$(port_listener_owner "$p")
        [[ -n "$owner" ]] || continue
        if [[ "$owner" != "$CURRENT_USER" ]]; then
            if [[ "$other_found" == false ]]; then
                out+="  Other users on this $PLATFORM_SHORT:"$'\n'
                other_found=true
            fi
            out+="    ${GREEN}●${NC} $owner — port $p"$'\n'
        fi
    done
    [[ "$other_found" == true ]] && out+=""$'\n'

    _STATUS_OUTPUT="$out"
}

run_status() {
    clear

    with_loading "Loading..." _collect_status_details

    if [[ "$_STATUS_OUTPUT" == "__empty__" ]]; then
        echo ""
        echo "  No OpenClaw profiles found on this account."
        echo ""
        echo "  Run 'Set up OpenClaw' from the main menu to get started."
        wait_for_key
        return
    fi

    echo ""
    gum style --border rounded --border-foreground 212 --padding "1 2" \
        --bold "Status & Profiles"
    echo ""

    echo -e "$_STATUS_OUTPUT"

    wait_for_key
}

# ═══════════════════════════════════════════════════════════════════════════
# BACKUP
# ═══════════════════════════════════════════════════════════════════════════

_BACKUP_CONFIG_COUNT=""
_BACKUP_SESSION_COUNT=""
_BACKUP_WORKSPACE_COUNT=""
_BACKUP_TOTAL_SIZE=""

_scan_backup_stats() {
    local oc_dir="$HOME/.openclaw"
    _BACKUP_CONFIG_COUNT=$(find "$oc_dir" -maxdepth 1 -name "*.json" -type f 2>/dev/null | wc -l | tr -d ' ')
    _BACKUP_SESSION_COUNT=$(find "$oc_dir/agents" -name "*.json" -type f 2>/dev/null | wc -l | tr -d ' ') || _BACKUP_SESSION_COUNT=0
    _BACKUP_WORKSPACE_COUNT=$(find "$oc_dir/workspace" -type f 2>/dev/null | wc -l | tr -d ' ') || _BACKUP_WORKSPACE_COUNT=0
    _BACKUP_TOTAL_SIZE=$(du -sh "$oc_dir" 2>/dev/null | cut -f1)
}

_run_backup_compress() {
    tar -czf "$1" \
        --exclude='*.sock' \
        --exclude='node_modules' \
        --exclude='logs' \
        -C "$HOME" .openclaw 2>/dev/null

    for d in "$HOME"/.openclaw-*/; do
        [[ -d "$d" ]] || continue
        local pname
        pname=$(basename "$d")
        tar -czf "${2}/${3}-${pname#.openclaw-}.tar.gz" \
            --exclude='*.sock' \
            --exclude='node_modules' \
            --exclude='logs' \
            -C "$HOME" "$pname" 2>/dev/null
    done
}

run_backup() {
    clear
    step "Backup OpenClaw"

    local oc_dir="$HOME/.openclaw"
    if [[ ! -d "$oc_dir" ]]; then
        fail "No ~/.openclaw/ directory found. Nothing to back up."
        wait_for_key
        return
    fi

    with_loading "Loading..." _scan_backup_stats

    echo "  What will be backed up:"
    echo "    Config files:    $_BACKUP_CONFIG_COUNT"
    echo "    Session files:   $_BACKUP_SESSION_COUNT"
    echo "    Workspace files: $_BACKUP_WORKSPACE_COUNT"
    echo "    Total size:      $_BACKUP_TOTAL_SIZE"
    echo ""

    local backup_dest
    backup_dest=$(get_desktop_path)

    if ! gum confirm "Create backup in $backup_dest/?"; then
        return
    fi

    local timestamp backup_name backup_file
    timestamp=$(date +%Y%m%d_%H%M%S)
    backup_name="openclaw-backup-${CURRENT_USER}-${timestamp}"
    backup_file="${backup_dest}/${backup_name}.tar.gz"

    echo ""
    with_loading "Compressing..." _run_backup_compress "$backup_file" "$backup_dest" "$backup_name"

    local backup_size
    backup_size=$(du -h "$backup_file" | cut -f1)
    info "Backup created: $backup_file ($backup_size)"

    for d in "$HOME"/.openclaw-*/; do
        [[ -d "$d" ]] || continue
        local pname
        pname=$(basename "$d")
        info "Also backed up: ${pname#.openclaw-}"
    done

    echo ""
    echo "  To restore:"
    echo "    tar -xzf $backup_file -C ~/"
    echo "    openclaw gateway install --force && openclaw gateway start"

    wait_for_key
}

# ═══════════════════════════════════════════════════════════════════════════
# MIGRATE (fix paths after home rename)
# ═══════════════════════════════════════════════════════════════════════════

run_migrate() {
    clear
    step "Fix paths after home directory rename"

    echo "  If you renamed your $PLATFORM_NAME username (e.g. clawsy -> ted),"
    echo "  OpenClaw configs still reference the old home path."
    echo "  This fixes all of them."
    echo ""

    local old_home new_home
    old_home=$(gum input --header "Old home path" --placeholder "e.g. /Users/clawsy or /home/clawsy") || return
    [[ -n "$old_home" ]] || { fail "Old path cannot be empty"; wait_for_key; return; }

    new_home=$(gum input --header "New home path" --placeholder "e.g. /Users/ted or /home/ted") || return
    [[ -n "$new_home" ]] || { fail "New path cannot be empty"; wait_for_key; return; }

    if [[ ! -d "$new_home" ]]; then
        fail "$new_home does not exist"
        wait_for_key
        return
    fi

    info "Old: $old_home"
    info "New: $new_home"
    echo ""

    local target_files=()
    local oc_dir="$new_home/.openclaw"

    if [[ -d "$oc_dir" ]]; then
        while IFS= read -r -d '' f; do
            if grep -q "$old_home" "$f" 2>/dev/null; then
                local count
                count=$(grep -c "$old_home" "$f" 2>/dev/null || echo 0)
                target_files+=("$f")
                echo "  Found $count references in ${f#$new_home/}"
            fi
        done < <(find "$oc_dir" -name "*.json" -type f -print0 2>/dev/null)
    fi

    for f in \
        "$new_home/.claude.json" \
        "$new_home/.claude/plugins/known_marketplaces.json" \
        "$new_home/.claude/settings.local.json" \
    ; do
        if [[ -f "$f" ]] && grep -q "$old_home" "$f" 2>/dev/null; then
            local count
            count=$(grep -c "$old_home" "$f" 2>/dev/null || echo 0)
            target_files+=("$f")
            echo "  Found $count references in ${f#$new_home/}"
        fi
    done

    if [[ ${#target_files[@]} -eq 0 ]]; then
        info "No files contain references to $old_home — nothing to migrate!"
        wait_for_key
        return
    fi

    echo ""
    echo "  Total files to update: ${#target_files[@]}"
    echo ""

    if ! gum confirm "Apply changes?"; then
        return
    fi

    local backup_dir="$new_home/.openclaw/migration-backup-$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"

    for f in "${target_files[@]}"; do
        local rel_path="${f#$new_home/}"
        local bpath="$backup_dir/$rel_path"
        mkdir -p "$(dirname "$bpath")"
        cp "$f" "$bpath"
        sed_inplace "s|$old_home|$new_home|g" "$f"
        info "Fixed: $rel_path"
    done

    info "Backups saved to: $backup_dir"
    echo ""
    echo "  Next: openclaw gateway restart"

    wait_for_key
}

# ═══════════════════════════════════════════════════════════════════════════
# NUKE (clean uninstall)
# ═══════════════════════════════════════════════════════════════════════════

run_nuke() {
    clear

    echo -e "  ${RED}━━━ Clean Uninstall ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo "  This will stop your OpenClaw daemon and remove the $DAEMON_TYPE."
    echo "  You can optionally wipe all data (config, sessions, workspace)."
    echo ""
    echo "  User: $CURRENT_USER"
    echo ""

    if ! gum confirm "Proceed with OpenClaw removal?"; then
        return
    fi

    step "Stopping gateway"
    if command -v openclaw &>/dev/null; then
        openclaw gateway stop 2>/dev/null && info "Gateway stopped" || true
    fi

    if [[ -f "$HOME/.openclaw/openclaw.json" ]]; then
        local port
        port=$(python3 -c "
import json
try:
    c = json.load(open('$HOME/.openclaw/openclaw.json'))
    print(c.get('gateway', {}).get('port', ''))
except: pass
" 2>/dev/null || true)
        if [[ -n "$port" ]]; then
            local pids
            pids=$(port_listener_pids "$port")
            for pid in $pids; do
                kill "$pid" 2>/dev/null && info "Killed process $pid" || true
            done
        fi
    fi

    step "Removing $DAEMON_TYPE"
    daemon_uninstall ""

    for d in "$HOME"/.openclaw-*/; do
        [[ -d "$d" ]] || continue
        local pname
        pname=$(basename "$d" | sed 's/^\.openclaw-//')
        daemon_uninstall "$pname"
    done

    echo ""
    if gum confirm "Also remove ALL OpenClaw data (~/.openclaw/ and profiles)?"; then
        step "Backup"
        local backup_dest
        backup_dest=$(get_desktop_path)
        local backup_file="${backup_dest}/openclaw-backup-nuke-$(date +%Y%m%d_%H%M%S).tar.gz"
        echo "  Creating safety backup..."
        local dirs_to_backup=(".openclaw")
        for d in "$HOME"/.openclaw-*/; do
            [[ -d "$d" ]] && dirs_to_backup+=("$(basename "$d")")
        done
        tar -czf "$backup_file" -C "$HOME" "${dirs_to_backup[@]}" 2>/dev/null || true
        info "Backup saved: $backup_file"

        step "Removing data"
        echo ""
        echo -e "  ${RED}This will permanently delete:${NC}"
        echo "    ~/.openclaw/"
        for d in "$HOME"/.openclaw-*/; do
            [[ -d "$d" ]] && echo "    ~/$(basename "$d")/"
        done
        echo ""

        local confirm
        confirm=$(gum input --header "Type NUKE to confirm" --placeholder "NUKE") || return
        if [[ "$confirm" == "NUKE" ]]; then
            rm -rf "$HOME/.openclaw"
            for d in "$HOME"/.openclaw-*/; do
                [[ -d "$d" ]] && rm -rf "$d"
            done
            info "All OpenClaw data removed"
        else
            warn "Skipped — data preserved"
        fi
    else
        info "Data preserved at ~/.openclaw/"
    fi

    if [[ -d /tmp/openclaw ]]; then
        find /tmp/openclaw -user "$CURRENT_USER" -delete 2>/dev/null || true
        info "Cleaned /tmp/openclaw/"
    fi

    echo ""
    echo -e "  ${GREEN}OpenClaw removed for $CURRENT_USER${NC}"
    echo ""
    echo "  To reinstall, run this tool again and choose 'Set up OpenClaw'"

    wait_for_key
}

# ═══════════════════════════════════════════════════════════════════════════
# MAIN LOOP
# ═══════════════════════════════════════════════════════════════════════════

main() {
    while true; do
        detect_status
        clear

        echo ""
        gum style --border rounded --border-foreground 99 --padding "1 2" --width 58 \
            --align center --bold "OpenClaw Tools" \
            "" \
            "$(status_header)"
        echo ""

        local choice
        choice=$(gum choose \
            "Set up OpenClaw" \
            "Status & profiles" \
            "Backup" \
            "Fix paths after home rename" \
            "Clean uninstall" \
            "Exit") || break

        case "$choice" in
            "Set up"*) run_setup ;;
            "Status"*) run_status ;;
            "Backup") run_backup ;;
            "Fix paths"*) run_migrate ;;
            "Clean"*) run_nuke ;;
            "Exit") clear; break ;;
        esac
    done
}

main
